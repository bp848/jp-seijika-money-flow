"use server"

import Groq from "groq-sdk"
import { createSupabaseServerClient } from "@/lib/supabase/client"
import type { TablesInsert } from "@/types/supabase" // Assuming you have a types/supabase.ts generated by Supabase CLI
import { head, put } from "@vercel/blob"
import crypto from "crypto"

// Define a more specific type for the expected Groq API response structure
// This should mirror the JSON structure requested in the prompt
interface GroqParsedReport {
  political_organization?: {
    name?: string
    address?: string
    representative_name?: string
    accountant_name?: string
    report_year?: number
  }
  financial_summary?: {
    prev_year_balance?: number
    current_year_revenue?: number
    total_revenue?: number
    total_expenditure?: number
    next_year_balance?: number
  }
  revenues?: Array<{
    category?: string
    item_name?: string
    amount?: number
    donor_name?: string
    donor_address?: string
    donor_occupation?: string
    donation_date_str?: string // Groq might return date as string
    remarks?: string
    source_document_page?: string
  }>
  expenditures?: Array<{
    category?: string
    item_name?: string
    purpose?: string
    amount?: number
    expenditure_date_str?: string // Groq might return date as string
    payee_name?: string
    payee_address?: string
    remarks?: string
    source_document_page?: string
  }>
  assets?: Array<{
    asset_type?: string
    description?: string
    value?: number
    acquisition_date_str?: string // Groq might return date as string
    remarks?: string
    source_document_page?: string
  }>
  audit_documents?: Array<{
    document_type?: string
    has_document?: boolean
    auditor_name?: string
    audit_date_str?: string // Groq might return date as string
  }>
}

function safeParseInt(value: any): number | undefined {
  if (value === null || value === undefined || value === "") return undefined
  const num = Number.parseInt(String(value).replace(/,/g, ""), 10)
  return isNaN(num) ? undefined : num
}

function safeParseDate(dateStr: string | undefined): string | undefined {
  if (!dateStr) return undefined
  try {
    // Attempt to parse common Japanese date formats or YYYY-MM-DD
    // Example: "令和6年5月20日", "2024年5月20日", "2024-05-20"
    // This is a simplified parser. A robust solution would use a date library.
    const eraPatterns = [
      { era: "令和", startYear: 2019 - 1 },
      { era: "平成", startYear: 1989 - 1 },
      { era: "昭和", startYear: 1926 - 1 },
    ]

    for (const pattern of eraPatterns) {
      const match = dateStr.match(new RegExp(`${pattern.era}(\\d+|元)年(\\d+)月(\\d+)日`))
      if (match) {
        const yearInEra = match[1] === "元" ? 1 : Number.parseInt(match[1], 10)
        const month = Number.parseInt(match[2], 10)
        const day = Number.parseInt(match[3], 10)
        const gregorianYear = pattern.startYear + yearInEra
        return `${gregorianYear}-${String(month).padStart(2, "0")}-${String(day).padStart(2, "0")}`
      }
    }

    const ymdMatch = dateStr.match(/(\d{4})年(\d{1,2})月(\d{1,2})日/)
    if (ymdMatch) {
      return `${ymdMatch[1]}-${String(ymdMatch[2]).padStart(2, "0")}-${String(ymdMatch[3]).padStart(2, "0")}`
    }

    if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
      return dateStr
    }

    // If no known format matches, return undefined or attempt a direct Date parse (less reliable)
    const parsed = new Date(dateStr)
    if (!isNaN(parsed.getTime())) {
      return parsed.toISOString().split("T")[0]
    }
  } catch (e) {
    console.warn(`Failed to parse date string: ${dateStr}`, e)
  }
  return undefined
}

export async function processReport(
  ocrText: string,
  reportId: string,
): Promise<{ success: boolean; message: string; data?: any; error?: string }> {
  if (!ocrText.trim()) {
    return { success: false, message: "OCRテキストが空です。" }
  }
  if (!reportId.trim()) {
    return { success: false, message: "レポートIDが空です。" }
  }

  const supabase = createSupabaseServerClient()
  const groqApiKey = process.env.GROQ_API_KEY
  if (!groqApiKey) {
    return { success: false, message: "GROQ_API_KEYが設定されていません。" }
  }

  // --- 重複チェックロジック ---
  // 1. コンテンツ自体のハッシュ値で重複チェック
  const contentHash = crypto.createHash("sha256").update(ocrText).digest("hex")
  const { data: existingReport, error: hashCheckError } = await supabase
    .from("political_organizations")
    .select("report_id")
    .eq("content_hash", contentHash)
    .single()

  if (hashCheckError && hashCheckError.code !== "PGRST116") {
    // 'PGRST116' is "No rows found"
    return { success: false, message: `データベース確認エラー: ${hashCheckError.message}` }
  }
  if (existingReport) {
    return { success: false, message: `この内容は既にレポートID「${existingReport.report_id}」として処理済みです。` }
  }

  // 2. レポートID (ファイルパス) での重複チェック
  const blobPath = `reports/${reportId}.txt`
  try {
    await head(blobPath)
    // headが成功した場合、ファイルが存在する
    return { success: false, message: `レポートID「${reportId}」は既に処理済みです（Blobファイルが存在します）。` }
  } catch (error: any) {
    if (error.status !== 404) {
      // 404以外のエラーは予期せぬ問題
      console.error("Vercel Blob head request error:", error)
      return { success: false, message: `Blobストレージの確認中にエラーが発生しました: ${error.message}` }
    }
    // 404エラーはファイルが存在しないことを意味するため、処理を続行
  }
  // --- 重複チェックここまで ---

  const groq = new Groq({ apiKey: groqApiKey })

  try {
    const chatCompletion = await groq.chat.completions.create({
      messages: [
        {
          role: "system",
          content: `あなたは日本の政治資金収支報告書を解析する専門家です。提供されたOCRテキストから情報を抽出し、指定されたJSON形式で出力してください。
金額は数値型(整数)で、カンマや円マークは含めないでください。日付は可能な限りYYYY-MM-DD形式で抽出してください。
該当情報がない場合はプロパティ自体を省略するか、nullとしてください。
JSON構造の例:
{
  "political_organization": { "name": "...", "address": "...", "representative_name": "...", "accountant_name": "...", "report_year": 2023 },
  "financial_summary": { "prev_year_balance": 1000000, "current_year_revenue": 5000000, "total_revenue": 6000000, "total_expenditure": 4000000, "next_year_balance": 2000000 },
  "revenues": [ { "category": "...", "item_name": "...", "amount": 50000, "donor_name": "...", "donor_address": "...", "donor_occupation": "...", "donation_date_str": "2023-04-01", "remarks": "...", "source_document_page": "その2" } ],
  "expenditures": [ { "category": "...", "item_name": "...", "purpose": "...", "amount": 30000, "expenditure_date_str": "2023-05-10", "payee_name": "...", "payee_address": "...", "remarks": "...", "source_document_page": "その13" } ],
  "assets": [ { "asset_type": "...", "description": "...", "value": 1000000, "acquisition_date_str": "2020-01-15", "remarks": "...", "source_document_page": "その18" } ],
  "audit_documents": [ { "document_type": "監査意見書", "has_document": true, "auditor_name": "...", "audit_date_str": "2024-03-10" } ]
}
`,
        },
        {
          role: "user",
          content: `以下のOCRテキストを解析してください:\n\n---\n${ocrText}\n---`,
        },
      ],
      model: "llama3-70b-8192", // or other suitable model like 'mixtral-8x7b-32768'
      temperature: 0.1, // Lower temperature for more deterministic output
      response_format: { type: "json_object" },
    })

    const rawJson = chatCompletion.choices[0]?.message?.content
    if (!rawJson) {
      return { success: false, message: "Groqからの応答が空です。" }
    }

    let parsedData: GroqParsedReport
    try {
      parsedData = JSON.parse(rawJson) as GroqParsedReport
    } catch (e: any) {
      console.error("Groq JSON parsing error:", e, "Raw JSON:", rawJson)
      return { success: false, message: `GroqからのJSON解析に失敗しました: ${e.message}`, error: rawJson }
    }

    // Begin Supabase transaction
    // Note: Supabase JS client doesn't directly support multi-statement transactions like SQL.
    // We'll perform operations sequentially and rely on idempotency or manual cleanup if partial failure.
    // For true atomicity, a pg_net stored procedure callable from Supabase would be better.

    // --- 処理成功後にBlobファイルを作成 ---
    const { url: blobUrl } = await put(blobPath, ocrText, {
      access: "public",
      addRandomSuffix: false, // レポートIDをそのままファイル名として使用
    })
    // --- Blob作成ここまで ---

    const orgData: TablesInsert<"political_organizations"> = {
      report_id: reportId,
      name: parsedData.political_organization?.name,
      address: parsedData.political_organization?.address,
      representative_name: parsedData.political_organization?.representative_name,
      accountant_name: parsedData.political_organization?.accountant_name,
      report_year: safeParseInt(parsedData.political_organization?.report_year),
      raw_ocr_text: ocrText,
      blob_url: blobUrl, // Blob URLを保存
      content_hash: contentHash, // コンテンツハッシュを保存
    }
    const { error: orgError } = await supabase
      .from("political_organizations")
      .upsert(orgData, { onConflict: "report_id" })
    if (orgError) throw new Error(`政治団体情報の保存エラー: ${orgError.message}`)

    if (parsedData.financial_summary) {
      const summaryData: TablesInsert<"financial_summaries"> = {
        organization_report_id: reportId,
        prev_year_balance: safeParseInt(parsedData.financial_summary.prev_year_balance),
        current_year_revenue: safeParseInt(parsedData.financial_summary.current_year_revenue),
        total_revenue: safeParseInt(parsedData.financial_summary.total_revenue),
        total_expenditure: safeParseInt(parsedData.financial_summary.total_expenditure),
        next_year_balance: safeParseInt(parsedData.financial_summary.next_year_balance),
      }
      // Upsert based on organization_report_id. If your table has a unique constraint on it.
      // If not, you might need to delete existing then insert.
      await supabase.from("financial_summaries").delete().eq("organization_report_id", reportId)
      const { error: summaryError } = await supabase.from("financial_summaries").insert(summaryData)
      if (summaryError) throw new Error(`収支総括表の保存エラー: ${summaryError.message}`)
    }

    if (parsedData.revenues && parsedData.revenues.length > 0) {
      await supabase.from("revenue_details").delete().eq("organization_report_id", reportId)
      const revenueInserts: TablesInsert<"revenue_details">[] = parsedData.revenues.map((r) => ({
        organization_report_id: reportId,
        category: r.category,
        item_name: r.item_name,
        amount: safeParseInt(r.amount),
        donor_name: r.donor_name,
        donor_address: r.donor_address,
        donor_occupation: r.donor_occupation,
        donation_date: safeParseDate(r.donation_date_str),
        remarks: r.remarks,
        source_document_page: r.source_document_page,
      }))
      const { error: revenueError } = await supabase.from("revenue_details").insert(revenueInserts)
      if (revenueError) throw new Error(`収入詳細の保存エラー: ${revenueError.message}`)
    }

    if (parsedData.expenditures && parsedData.expenditures.length > 0) {
      await supabase.from("expenditure_details").delete().eq("organization_report_id", reportId)
      const expenditureInserts: TablesInsert<"expenditure_details">[] = parsedData.expenditures.map((e) => ({
        organization_report_id: reportId,
        category: e.category,
        item_name: e.item_name,
        purpose: e.purpose,
        amount: safeParseInt(e.amount),
        expenditure_date: safeParseDate(e.expenditure_date_str),
        payee_name: e.payee_name,
        payee_address: e.payee_address,
        remarks: e.remarks,
        source_document_page: e.source_document_page,
      }))
      const { error: expenditureError } = await supabase.from("expenditure_details").insert(expenditureInserts)
      if (expenditureError) throw new Error(`支出詳細の保存エラー: ${expenditureError.message}`)
    }

    if (parsedData.assets && parsedData.assets.length > 0) {
      await supabase.from("asset_details").delete().eq("organization_report_id", reportId)
      const assetInserts: TablesInsert<"asset_details">[] = parsedData.assets.map((a) => ({
        organization_report_id: reportId,
        asset_type: a.asset_type,
        description: a.description,
        value: safeParseInt(a.value),
        acquisition_date: safeParseDate(a.acquisition_date_str),
        remarks: a.remarks,
        source_document_page: a.source_document_page,
      }))
      const { error: assetError } = await supabase.from("asset_details").insert(assetInserts)
      if (assetError) throw new Error(`資産等詳細の保存エラー: ${assetError.message}`)
    }

    if (parsedData.audit_documents && parsedData.audit_documents.length > 0) {
      await supabase.from("audit_documents").delete().eq("organization_report_id", reportId)
      const auditInserts: TablesInsert<"audit_documents">[] = parsedData.audit_documents.map((doc) => ({
        organization_report_id: reportId,
        document_type: doc.document_type,
        has_document: doc.has_document,
        auditor_name: doc.auditor_name,
        audit_date: safeParseDate(doc.audit_date_str),
      }))
      const { error: auditError } = await supabase.from("audit_documents").insert(auditInserts)
      if (auditError) throw new Error(`監査書類情報の保存エラー: ${auditError.message}`)
    }

    return { success: true, message: "レポートの処理と保存が完了しました。", data: parsedData }
  } catch (error: any) {
    console.error("Error processing report:", error)
    return { success: false, message: `処理中にエラーが発生しました: ${error.message}`, error: error.toString() }
  }
}
